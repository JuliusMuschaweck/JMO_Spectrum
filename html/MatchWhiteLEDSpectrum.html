
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MatchWhiteLEDSpectrum</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-02-12"><meta name="DC.source" content="MatchWhiteLEDSpectrum.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>MatchWhiteLEDSpectrum</h1><!--introduction--><p>
 <p style="font-size:75%;">Navigate to: &nbsp;
<a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
<a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp;
<a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp;
Source code: <a href = "file:../MatchWhiteLEDSpectrum.m"> MatchWhiteLEDSpectrum.m</a>
</p>
</p><p>Given a white LED spectrum, modifies it to match a desired CIE XYZ target (e.g. for LEDs from a different white bin, or at different operating conditions)</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Input Arguments</a></li><li><a href="#3">Output Arguments</a></li><li><a href="#4">Algorithm</a></li><li><a href="#5">See also</a></li><li><a href="#6">Usage Example</a></li></ul></div><h2 id="1">Syntax</h2><p><tt>rv = MatchWhiteLEDSpectrum(whiteLEDspectrum, XYZ_target)</tt></p><h2 id="2">Input Arguments</h2><div><ul><li><tt>whiteLEDspectrum</tt>: A white LED spectrum, with a blue peak and a yellow peak, with a minimum near 480 nm in between</li><li><tt>XYZ_target</tt>: A struct with fields <tt>x,y,Y</tt>, i.e. the desired x-y white point and the Y tristimulus value. % Note that you need to multiply the tristimulus Y value with Km = 683 lm/W to get photometric units (lm, cd, lux).</li></ul></div><h2 id="3">Output Arguments</h2><div><ul><li><tt>rv</tt>: A struct with fields <tt>spec</tt>: A white LED spectrum, i.e. a struct with fields <tt>lam</tt> and <tt>val</tt>, which has the desired x-y white point and the desired tristimulus Y value, <tt>blue</tt>, the shifted blue part of the spectrum, <tt>yellow</tt>, the shifted yellow part of the spectrum, and <tt>target</tt>, a copy of the <tt>XYZ_target</tt> input parameter.</li></ul></div><h2 id="4">Algorithm</h2><div><ol><li>Determines the location of the minimum near 480 nm.</li><li>Splits the input spectrum smoothly, using a <tt>tanh</tt> weighting function with a width of 10 nm, into a blue part and a yellow part, which overlap around the white spectrum's minimum.</li><li>The desired white point will generally not lie on the line in the CIRE xy diagram which connects the color coordinates of the blue and the yellow part. If the desired white point is above/below this line, the blue part is shifted towards longer/shorter wavelenghts and the yellow part by the same shift towards shorter/longer wavelengths, such that the desired white point lies on the line connecting the shifted blue and yellow spectra.</li><li>The shifted blue and yellow spectra are scaled to match the desired whited point and the desired tristimulus Y value.</li></ol></div><p>When it would be necessary to shift the blue/yellow parts by more than 10 nm, the routine emits an error.</p><p>In practice, the actual white spectrum of a LED of the same type, but from a different white bin, will not exactly be what this function returns. However, it would be wrong to shift only the blue part, or only the yellow part. Binning variations are caused by varying phosphor amounts (which do not require shifting, just rebalancing blue and yellow), by variations/shifts in the underlying blue LED spectrum, and by variations of the phosphor spectrum. Similar considerations apply to flux and white point variations due to current/temperature changes. This routine uses a heuristic approach to modify the original white spectrum in a reasonable way, such that a given color and flux shift is achieved.</p><p>With this routine, it is possible to implement a white LED model, which returns the actual spectrum under operating conditions for a white LED, given only data sheet information.</p><h2 id="5">See also</h2><p><a href="CIE1931_XYZ.html">CIE1931_XYZ</a>, <a href="ResampleSpectrum.html">ResampleSpectrum</a>, <a href="ShiftToLdom.html">ShiftToLdom</a></p><h2 id="6">Usage Example</h2><pre class="language-matlab">
<span class="keyword">function</span> ExampleMatchWhiteLEDSpectrum()
    
    <span class="comment">% source LED spectrum at 4003 K</span>
    spec = ReadLightToolsSpectrumFile(<span class="string">'LED_4003K.sre'</span>);
    spec.XYZ = CIE1931_XYZ(spec);
    
    matchOriginal = MatchWhiteLEDSpectrum(spec, spec.XYZ);
    delta = matchOriginal.spec.val - spec.val;
    test = max(abs(delta)) &lt; 1e-14;
    fprintf(<span class="string">'match original deviation : %g\n'</span>,max(abs(delta)));
    
    <span class="comment">% prepare target at 4500K Planck</span>
    xyt = PlanckLocus().xy_func(4500);
    xt = xyt(1);
    yt = xyt(2);
    Yt = spec.XYZ.Y * 1.2; <span class="comment">% a little more flux</span>
    XYZ_target = XYZ_from_xyY(xt, yt, Yt);
    
    
    match4500 = MatchWhiteLEDSpectrum(spec, XYZ_target);
    
<span class="comment">    %%</span>
    figure();
    clf;
    hold <span class="string">on</span>;
    plot(spec.lam, spec.val,<span class="string">'k'</span>);
    plot(match4500.spec.lam, match4500.spec.val, <span class="string">' m'</span>,<span class="string">'LineWidth'</span>,2);
    plot(match4500.blue.lam, match4500.blue.val, <span class="string">'--b'</span>,<span class="string">'LineWidth'</span>,2);
    plot(match4500.yellow.lam, match4500.yellow.val, <span class="string">'--'</span>,<span class="string">'Color'</span>, [0, 0.7, 0],<span class="string">'LineWidth'</span>,2);
    xlabel(<span class="string">'\lambda (nm)'</span>);
    legend({<span class="string">'original LED'</span>,<span class="string">'target matched LED'</span>,<span class="string">'blue part'</span>,<span class="string">'yellow part'</span>});
    title(<span class="string">'Matching white LED spectrum to different white point'</span>);
    
    fh = figure();
    clf;
    PlotCIExyBorder(<span class="string">'Figure'</span>,fh,<span class="string">'ColorFill'</span>, true);
    axis <span class="string">equal</span>;
    axis([0 0.8 0 0.9]);
    hold <span class="string">on</span>;
    scatter(spec.XYZ.x, spec.XYZ.y,<span class="string">'k'</span>);
    scatter(xt, yt,<span class="string">'x'</span>);
    scatter(matchOriginal.blue.XYZ.x, matchOriginal.blue.XYZ.y,<span class="string">'y'</span>);
    scatter(match4500.blue.XYZ.x, match4500.blue.XYZ.y,<span class="string">'xy'</span>);
    
    scatter(matchOriginal.yellow.XYZ.x, matchOriginal.yellow.XYZ.y,<span class="string">'b'</span>);
    scatter(match4500.yellow.XYZ.x, match4500.yellow.XYZ.y,<span class="string">'xb'</span>);
    
    plot([matchOriginal.blue.XYZ.x, matchOriginal.yellow.XYZ.x],[matchOriginal.blue.XYZ.y, matchOriginal.yellow.XYZ.y],<span class="string">'k'</span>);
    plot([match4500.blue.XYZ.x, match4500.yellow.XYZ.x],[match4500.blue.XYZ.y, match4500.yellow.XYZ.y],<span class="string">'k'</span>);
    xlabel(<span class="string">'CIE x'</span>);
    ylabel(<span class="string">'CIE y'</span>);
    title(<span class="string">'Matching white LED to different white point'</span>);
    
<span class="keyword">end</span>

</pre><pre class="codeoutput">match original deviation : 8.88178e-16
</pre><img vspace="5" hspace="5" src="MatchWhiteLEDSpectrum_01.png" alt=""> <img vspace="5" hspace="5" src="MatchWhiteLEDSpectrum_02.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% MatchWhiteLEDSpectrum
% 
% <html>
%  <p style="font-size:75%;">Navigate to: &nbsp; 
% <a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
% <a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp; 
% <a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp; 
% Source code: <a href = "file:../MatchWhiteLEDSpectrum.m"> MatchWhiteLEDSpectrum.m</a>
% </p>
% </html>
%
% Given a white LED spectrum, modifies it to match a desired CIE XYZ target (e.g. for LEDs from a different white bin, or at different operating conditions)
%% Syntax
% |rv = MatchWhiteLEDSpectrum(whiteLEDspectrum, XYZ_target)|
%% Input Arguments
% * |whiteLEDspectrum|: A white LED spectrum, with a blue peak and a yellow peak, with a minimum near 480 nm in between
% * |XYZ_target|: A struct with fields |x,y,Y|, i.e. the desired x-y white point and the Y tristimulus value. % Note that you need to multiply the tristimulus Y value with Km = 683 lm/W
% to get photometric units (lm, cd, lux).
%% Output Arguments
% * |rv|: A struct with fields |spec|: A white LED spectrum, i.e. a struct with fields |lam| and |val|, 
% which has the desired x-y white point and the desired tristimulus Y value, |blue|, the shifted blue part of the spectrum,
% |yellow|, the shifted yellow part of the spectrum, and |target|, a copy of the |XYZ_target| input parameter.
%% Algorithm
% # Determines the location of the minimum near 480 nm. 
% # Splits the input spectrum smoothly, using a |tanh| weighting function with a width of 10 nm, into a blue part
% and a yellow part, which overlap around the white spectrum's minimum.
% # The desired white point will generally not lie on the line in the CIRE xy diagram which connects the 
% color coordinates of the blue and the yellow part. If the desired white point is above/below this line, the blue part is 
% shifted towards longer/shorter wavelenghts and the yellow part by the same shift towards shorter/longer wavelengths, such that 
% the desired white point lies on the line connecting the shifted blue and yellow spectra. 
% # The shifted blue and yellow spectra are scaled to match the desired whited point and the desired tristimulus Y
% value.
%
% When it would be necessary to shift the blue/yellow parts by more than 10 nm, the routine emits an error.
%
% In practice, the actual white spectrum of a LED of the same type, but from a different white bin, will not exactly be
% what this function returns. However, it would be wrong to shift only the blue part, or only the yellow part.
% Binning variations are caused by varying phosphor amounts (which do not require shifting, just rebalancing blue and
% yellow), by variations/shifts in the underlying blue LED spectrum, and by variations of the phosphor spectrum.
% Similar considerations apply to flux and white point variations due to current/temperature changes. This routine 
% uses a heuristic approach to modify the original white spectrum in a reasonable way, such that a given color and flux
% shift is achieved.
%
% With this routine, it is possible to implement a white LED model, which returns the actual spectrum under operating 
% conditions for a white LED, given only data sheet information.
%% See also
% <CIE1931_XYZ.html CIE1931_XYZ>, <ResampleSpectrum.html ResampleSpectrum>, <ShiftToLdom.html ShiftToLdom>
%% Usage Example
% <include>Examples/ExampleMatchWhiteLEDSpectrum.m</include>

% publish with publishWithStandardExample('filename.m') in PublishDocumentation.m

% JMO Spectrum Library, 2021. See https://github.com/JuliusMuschaweck/JMO_Spectrum
% I dedicate the JMO_Spectrum library to the public domain under Creative Commons Zero 
% (https://creativecommons.org/publicdomain/zero/1.0/legalcode)
%

function rv = MatchWhiteLEDSpectrum(whiteLEDspectrum, XYZ_target)
    
    % abbreviations
    xt = XYZ_target.x;
    yt = XYZ_target.y;
    xyt = [xt, yt];
    Yt = XYZ_target.Y;
    
    % find near 480nm minimum
    lam_overlap = 450:500;
    spec_overlap = ResampleSpectrum(whiteLEDspectrum, lam_overlap);
    [~,imin] = min(spec_overlap.val);
    lam_min = lam_overlap(imin);
    % split spectrum there with tanh weight, sigma = 10 nm
    sig = 10;
    ww = 0.5 * (1 + tanh( (whiteLEDspectrum.lam - lam_min) / sig ));
    ww( (1-ww) < 1e-4) = 1;
    ww( ww < 1e-4) = 0;
    iww = 1 - ww;
    
    blue = MakeSpectrumDirect(whiteLEDspectrum.lam, whiteLEDspectrum.val .* iww, 'XYZ', true);
    yellow = MakeSpectrumDirect(whiteLEDspectrum.lam, whiteLEDspectrum.val .* ww, 'XYZ', true);
    
    testshift = @(dlam) TestShift(dlam, blue, yellow, xyt);
    dlam_max = 10;
    if testshift(dlam_max) * testshift(-dlam_max) >= 0
        error('MatchWhiteLEDSpectrum: shift more than 10 nm needed');
    end
    % bracket established REPLACE_WITH_DASH_DASH find shift to bring target between blue and yellow
    [dlam, fb, nfe, ok, msg]= FindRoot1D(testshift, -dlam_max, dlam_max);
    blue_shifted = MakeSpectrumDirect(blue.lam + dlam,  blue.val, 'XYZ',true);
    yellow_shifted = MakeSpectrumDirect(yellow.lam - dlam,  yellow.val, 'XYZ',true);
    
    % compute weights
    blue_dist = norm([blue_shifted.XYZ.x, blue_shifted.XYZ.y] - xyt);
    yellow_dist = norm([yellow_shifted.XYZ.x, yellow_shifted.XYZ.y] - xyt);
    
    yfac1 = blue_dist * blue_shifted.XYZ.cw / (yellow_dist * yellow_shifted.XYZ.cw);
    fac2 = Yt / (blue_shifted.XYZ.Y + yfac1 * yellow_shifted.XYZ.Y);
    
    blue_shifted = MakeSpectrumDirect(blue_shifted.lam, blue_shifted.val * fac2, 'XYZ',true);
    yellow_shifted = MakeSpectrumDirect(yellow_shifted.lam, yellow_shifted.val * yfac1 * fac2, 'XYZ',true);
    
    matched_white = AddSpectra(blue_shifted, yellow_shifted);
    % test
    matched_white.XYZ = CIE1931_XYZ(matched_white);
    dY = matched_white.XYZ.Y - Yt;
    dxy = [matched_white.XYZ.x, matched_white.XYZ.y] - xyt;
    
    rv.spec = matched_white;
    rv.blue = blue_shifted;
    rv.yellow = yellow_shifted;
    rv.target = XYZ_target;
end

function rv = TestShift(dlam, blue, yellow, xyt)
    b = CIE1931_XYZ(struct('lam',blue.lam + dlam, 'val', blue.val));
    y = CIE1931_XYZ(struct('lam',yellow.lam - dlam, 'val', yellow.val));
    cross2 =@(lhs, rhs) lhs(1) * rhs(2) - lhs(2) * rhs(1);
    rv = cross2([y.x,y.y] - [b.x, b.y], xyt - [b.x, b.y]); %
end

##### SOURCE END #####
--></body></html>