<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>LDomPurity</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-08-26">
<meta name="DC.source" content="LDomPurity.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>LDomPurity</h1>
<!--introduction-->
<p>
 <p style="font-size:75%;">Navigate to: &nbsp;
<a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
<a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp;
<a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp;
Source code: <a href = "file:../LDomPurity.m"> LDomPurity.m</a>
</p>
</p>
<p>Computes dominant wavelength and purity</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Syntax</a>
</li>
<li>
<a href="#2">Input Arguments</a>
</li>
<li>
<a href="#3">Output Arguments</a>
</li>
<li>
<a href="#4">Algorithm</a>
</li>
<li>
<a href="#5">See also</a>
</li>
<li>
<a href="#6">Usage Example</a>
</li>
</ul>
</div>
<h2 id="1">Syntax</h2>
<p>
<tt>[ldom, purity] = LDomPurity(rhs, opts)</tt>
</p>
<h2 id="2">Input Arguments</h2>
<div>
<ul>
<li>
<tt>rhs</tt>: A valid spectrum (see <a href="IsSpectrum.html">IsSpectrum</a> for what that is), or</li>
<li>
<tt>rhs</tt>: alternatively, a struct with fieldy <tt>x</tt> and <tt>y</tt> (a CIE 1931 color point), or</li>
<li>
<tt>rhs</tt>: alternatively, a double vector of length 2, interpreted as an x-y CIE 1931 color point</li>
<li>
<tt>opts</tt>: Name-value pair, <tt>'E'</tt>, <tt>E</tt>, where <tt>E</tt> is a double vector of length 2, interpreted as an x-y CIE 1931 color, or a struct with fieldy <tt>x</tt> and <tt>y</tt>. <tt>E</tt> is the center point from where the dominant wavelength is determined. Default is <tt>E = [1/3, 1/3]</tt>.</li>
</ul>
</div>
<h2 id="3">Output Arguments</h2>
<div>
<ul>
<li>
<tt>ldom</tt>: scalar double: the dominant wavelength in nm. Negative when color point lies towards magenta line. 555 nm when color point coincides with white point within roundoff.</li>
<li>
<tt>purity</tt>: scalar double: the relative distance from the <tt>[1/3, 1/3]</tt> (or optional <tt>E</tt>) white point to the monochromatic border. Negative when colorpoint lies towards magenta line. Zero when color point coincides with white point within roundoff.</li>
</ul>
</div>
<h2 id="4">Algorithm</h2>
<p>First, computes the angle of the line from white point to border, to see if that is towards the monochromatic border or towards magenta line. Then, finds that monochromatic wavelength whose border point leads to the same angle, by iterative root finding. The monochromatic border points are taken from the CIE standard in 1 nm steps. In between a 1 nm interval, linear interpolation is used.</p>
<h2 id="5">See also</h2>
<p>
<a href="CIE1931_Data.html">CIE1931_Data</a>, <a href="ShiftToLdom.html">ShiftToLdom</a>
</p>
<h2 id="6">Usage Example</h2>
<pre class="language-matlab">
<span class="keyword">function</span> ExampleLDomPurity()
    cie = CIE1931_Data();
    xB = @(lam) interp1(cie.lam, cie.xBorder, lam);
    yB = @(lam) interp1(cie.lam, cie.yBorder, lam);
    red = GaussSpectrum(360:830, 620, 20);
    [ldomRed, purityRed] = LDomPurity(red);
    green = GaussSpectrum(360:830, 510, 20);
    [ldomGreen, purityGreen] = LDomPurity(green);
    fprintf(<span class="string">'ldom = %g, purity = %g for red\n'</span>,ldomRed, purityRed);
    fprintf(<span class="string">'ldom = %g, purity = %g for green\n'</span>,ldomGreen, purityGreen);
    PlotCIExyBorder();
    hold <span class="string">on</span>;
    scatter(1/3,1/3,<span class="string">'xk'</span>);
    xyRed = CIE1931_XYZ(red);
    xyGreen = CIE1931_XYZ(green);
    scatter(xyRed.x, xyRed.y,<span class="string">'or'</span>);
    plot([1/3,xyRed.x], [1/3, xyRed.y],<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,3);
    scatter(xyGreen.x, xyGreen.y,<span class="string">'og'</span>);
    plot([1/3,xyGreen.x], [1/3, xyGreen.y],<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,3);
    plot([1/3,xB(ldomGreen)], [1/3, yB(ldomGreen)],<span class="string">'g'</span>);
    <span class="comment">% compute directly from xy vector</span>
    [ldomMagenta, purityMagenta] = LDomPurity([0.4, 0.15]);
    <span class="comment">% or compute from xy struct</span>
    magenta_xy.x = 0.4;
    magenta_xy.y = 0.15;
    [ldomMagenta, purityMagenta] = LDomPurity(magenta_xy);
    scatter(magenta_xy.x, magenta_xy.y,<span class="string">'xm'</span>);
    plot([1/3,magenta_xy.x], [1/3, magenta_xy.y],<span class="string">'m'</span>,<span class="string">'LineWidth'</span>,3);
    plot([1/3,xB(-ldomMagenta)], [1/3, yB(-ldomMagenta)],<span class="string">'m'</span>);
    fprintf(<span class="string">'ldom = %g, purity = %g for magenta\n'</span>,ldomMagenta, purityMagenta);
    <span class="comment">% now with nonstandard white point: CIE D65</span>
    D65 = CIE_Illuminant(<span class="string">'D65'</span>);
    D65XYZ = CIE1931_XYZ(D65);
    myE = [D65XYZ.x, D65XYZ.y];
    [ldomGreen_D65, purityGreen_D65] = LDomPurity(green,<span class="string">'E'</span>,myE);
    fprintf(<span class="string">'ldom = %g, purity = %g for green with D65 white point\n'</span>,ldomGreen_D65, purityGreen_D65);
    <span class="comment">% sanity check</span>
    cie = CIE1931_Data();
    xy_green_pure = [interp1(cie.lam, cie.xBorder,ldomGreen_D65), interp1(cie.lam, cie.yBorder,ldomGreen_D65)];
    xy_green = [xyGreen.x, xyGreen.y];
    xy_D65 = [D65XYZ.x,D65XYZ.y];
    <span class="comment">% are they collinear? distance from point p0 to line p1-p2 is</span>
    d_green_pure = xy_green_pure - xy_D65;
    d_green = xy_green - xy_D65;
    dist = d_green - (d_green * d_green_pure' / (norm(d_green_pure))^2) * d_green_pure;
    <span class="comment">%ah = PlotCIExyBorder();</span>
    <span class="comment">%plot(ah, [D65XYZ.x, xy_green_pure(1) ], [D65XYZ.y, xy_green_pure(2)]);</span>
    <span class="comment">%plot(ah, [D65XYZ.x, xy_green(1) ], [D65XYZ.y, xy_green(2)]);</span>
<span class="keyword">end</span>

</pre>
<pre class="codeoutput">ldom = 607.113, purity = 0.999998 for red
ldom = 507.557, purity = 0.705528 for green
ldom = -531.109, purity = -0.841618 for magenta
ldom = 508.147, purity = 0.688516 for green with D65 white point
</pre>
<img vspace="5" hspace="5" src="LDomPurity_01.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% LDomPurity
% 
% <html>
%  <p style="font-size:75%;">Navigate to: &nbsp; 
% <a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
% <a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp; 
% <a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp; 
% Source code: <a href = "file:../LDomPurity.m"> LDomPurity.m</a>
% </p>
% </html>
%
% Computes dominant wavelength and purity
%% Syntax
% |[ldom, purity] = LDomPurity(rhs, opts)|
%% Input Arguments
% * |rhs|: A valid spectrum (see <IsSpectrum.html IsSpectrum> for what that is), or
% * |rhs|: alternatively, a struct with fieldy |x| and |y| (a CIE 1931 color point), or
% * |rhs|: alternatively, a double vector of length 2, interpreted as an x-y CIE 1931 color point
% * |opts|: Name-value pair, |'E'|, |E|, where |E| is a double vector of length 2, interpreted as an x-y CIE 1931 color,
% or a struct with fieldy |x| and |y|. |E| is the center point from where the dominant wavelength is determined. Default is |E = [1/3, 1/3]|.
%% Output Arguments
% * |ldom|: scalar double: the dominant wavelength in nm. Negative when color point lies towards magenta line. 555 nm
% when color point coincides with white point within roundoff.
% * |purity|: scalar double: the relative distance from the |[1/3, 1/3]| (or optional |E|) white point to the monochromatic border. 
%    Negative when colorpoint lies towards magenta line. Zero when color point coincides with white point within roundoff.
%% Algorithm
% First, computes the angle of the line from white point to border, to see if that is towards the monochromatic border
% or towards magenta line. Then, finds that monochromatic wavelength whose border point leads to the same angle, by iterative root finding. The
% monochromatic border points are taken from the CIE standard in 1 nm steps. In between a 1 nm interval, linear
% interpolation is used.
%% See also
% <CIE1931_Data.html CIE1931_Data>, <ShiftToLdom.html ShiftToLdom>
%% Usage Example
% <include>Examples/ExampleLDomPurity.m</include>

% publish with publishWithStandardExample('filename.m') in PublishDocumentation.m

% JMO Spectrum Library, 2021. See https://github.com/JuliusMuschaweck/JMO_Spectrum
% I dedicate the JMO_Spectrum library to the public domain under Creative Commons Zero 
% (https://creativecommons.org/publicdomain/zero/1.0/legalcode)
%
function [ldom, purity, xyBorder] = LDomPurity(rhs, opts)
    % Computes dominant wavelength in nm and purity, from E = (1/3,1/3). 
    % Ldom and purity negative if E -> x/y intersects magenta line, not the monochromatic border.
    % Returns [555,0] for x/y == E within circle of radius eps = 2.2e-16. 
    % Parameters: 
    %   rhs: may be spectrum (struct with lam and val), or XYZ (struct with x and y), or vector w length 2
    arguments
        rhs
        opts.E = [1/3.0, 1/3.0]
    end
    persistent CIE1931XYZ;
    if isempty(CIE1931XYZ)
        % 22.8.2024 now using official CIE data
        CIE1931XYZ = CIE1931_Data();
        % load('CIE1931_lam_x_y_z.mat','CIE1931XYZ');
    end
    % JM 28.1.2023: these lines take the longest time, replace by LinInterpol
    %xb = @(lambda) interp1(CIE1931XYZ.lam, CIE1931XYZ.xBorder, lambda);
    %yb = @(lambda) interp1(CIE1931XYZ.lam, CIE1931XYZ.yBorder, lambda);
    xb = @(lambda) LinInterpol(CIE1931XYZ.lam, CIE1931XYZ.xBorder, lambda);
    yb = @(lambda) LinInterpol(CIE1931XYZ.lam, CIE1931XYZ.yBorder, lambda);

    % atan2(y,x), not x,y(!), goes from -pi to pi, x axis is 0 y axis is pi/2
    % so atan2 jumps at the -x axis.
    % we rotate left by pi/2 such that the -x axis becomes the -y axis in CIE xy
    % and angle is continuous through the xy border  
    if isfield(rhs, 'lam')
        if isfield(rhs, 'XYZ')
            x0 = rhs.XYZ.x;
            y0 = rhs.XYZ.y;
        else
            XYZ=CIE1931_XYZ(rhs);
            x0 = XYZ.x;
            y0 = XYZ.y;
        end
    elseif isfield(rhs,'x')
        x0 = rhs.x;
        y0 = rhs.y;
    elseif isvector(rhs) && numel(rhs) == 2
        x0 = rhs(1);
        y0 = rhs(2);
    else
        error('LDomPurity: unknown rhs type (class %s)',class(rhs));
    end
    if isfield(opts.E,'x')
        Ex = opts.E.x;
        Ey = opts.E.y;
    elseif isvector(opts.E) && numel(opts.E) == 2
        Ex = opts.E(1);
        Ey = opts.E(2);
    else
        error('LDomPurity: unknown optional E type (class %s)',class(opts.E));
    end
    angle = @(lambda) atan2(- xb(lambda) + Ex, - Ey + yb(lambda));
%    dx0 = x0 - 1/3.0;
%    dy0 = y0 - 1/3.0;
    dx0 = x0 - Ex;
    dy0 = y0 - Ey;
    if (abs(dx0) < eps && abs(dy0) < eps)
        % x/y at white point
        ldom = 555; %arbitrary
        purity = 0;
        xyBorder = [xb(555),yb(555)];
        return;
    end
    % compute angle a0 of line from white point to x/y
    a0 = atan2(-dx0, dy0);
    % see if the line crosses the border or the magenta line. If it does, rotate by pi
    amax = angle(360);
    amin = angle(830);
    plusminus = +1.0;
    if (a0 > amax)
        a0 = a0 - pi;
        plusminus = -1.0;
    end
    if (a0 < amin)
        a0 = a0 + pi;
        plusminus = -1.0;
    end
    zerofun = @(lambda) angle(lambda) - a0;
    % sanity check
    if (zerofun(360) * zerofun(830)) >= 0
        error('LDomPurity: angle not bracketed');
    end
    % JM 29.1.2023: use FindRoot1D to improve speed
    % [ldom,~,exitflag,~] = fzero( zerofun, [360, 830]);
    [ldom, ~, ~, lDomOk] = FindRoot1D(zerofun, 360, 830,'throwOnFailure',false);
    % if exitflag ~= 1
    if ~lDomOk
        % this cannot happen...
        error('LDomPurity: Root finding failed, fzero exitflag = %g',exitflag);
    end
    xbldom   = xb(ldom);
    ybldom = yb(ldom);
    ldom = ldom  * plusminus;
    % JM 20230201: Fix small bug with purity always w.r.t 1/3, 1/3, not opts.E
%    purity = plusminus * norm([dx0,dy0]) / norm ([xbldom - 1/3.0, ybldom - 1/3.0]);
%    purity = plusminus * norm([dx0,dy0]) / norm ([xbldom - Ex, ybldom - Ey]);
    % now compute correct purity values for magenta line.
    if plusminus == 1.0
       purity = norm([dx0,dy0]) / norm ([xbldom - Ex, ybldom - Ey]);
       xyBorder = [xbldom, ybldom];
    else
       xyRed = [CIE1931XYZ.xBorder(end), CIE1931XYZ.yBorder(end)];
       xyViolet = [CIE1931XYZ.xBorder(1), CIE1931XYZ.yBorder(1)];
       xyBorder = lineIntersect(xyRed,xyViolet,[xbldom, ybldom],[Ex,Ey]);
       purity = - norm([dx0,dy0]) / norm(xyBorder - [Ex,Ey]);
    end
end


##### SOURCE END #####
-->
</body>
</html>
