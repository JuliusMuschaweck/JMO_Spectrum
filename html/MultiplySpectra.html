
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MultiplySpectra</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-02-12"><meta name="DC.source" content="MultiplySpectra.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>MultiplySpectra</h1><!--introduction--><p>
 <p style="font-size:75%;">Navigate to: &nbsp;
<a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
<a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp;
<a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp;
Source code: <a href = "file:../MultiplySpectra.m"> MultiplySpectra.m</a>
</p>
</p><p>Multiply two spectra</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Input Arguments</a></li><li><a href="#3">Output Arguments</a></li><li><a href="#4">Algorithm</a></li><li><a href="#5">See also</a></li><li><a href="#6">Usage Example</a></li></ul></div><h2 id="1">Syntax</h2><p>rv = <tt>MultiplySpectra(lhs, rhs)</tt></p><h2 id="2">Input Arguments</h2><div><ul><li><tt>lhs</tt>: A valid spectrum, i.e. a struct with two array fields, <tt>lam</tt> and <tt>val</tt> (see <a href="SpectrumSanityCheck.html">SpectrumSanityCheck</a> for detailed requirements)</li><li><tt>rhs</tt>: Likewise</li></ul></div><h2 id="3">Output Arguments</h2><div><ul><li><tt>rv</tt>: A spectrum modeling the product.</li></ul></div><h2 id="4">Algorithm</h2><p>A spectrum in this library models a continuous, piecewise linear function of wavelength. For a given array of wavelenghts, the modeled spectrum is linear between wavelength points, and zero outside the wavelength domain. At the ends of the wavelength domain the modeled spectrum may drop discontinously to zero. (If you don't like these discontinuities at the domain boundary, add end points with zero values.). The product spectrum's wavelength points consist of the "interweaved" wavelength arrays of <tt>lhs</tt> and|rhs|, where they overlap. If they don't overlap at all, a spectrum is returned with two wavelength points and both values zero.</p><p>At each wavelength point, one value is taken from the corresponding point of one spectrum and the linearly interpolated point of the other spectrum, then these two are multiplied. Strictly speaking, the product spectrum would not be piecewise linear, it would be piecewise quadratic. However, this is neglected here. If a better approximation to the quadratic product spectrum is desired, you may resample <tt>lhs</tt> and/or <tt>rhs</tt> on a finer wavelength array using <a href="ResampleSpectrum.html">ResampleSpectrum</a>.</p><h2 id="5">See also</h2><p><a href="AddSpectra.html">AddSpectra</a>, <a href="AddWeightedSpectra.html">AddWeightedSpectra</a>, <a href="IntegrateSpectrum.html">IntegrateSpectrum</a>, <a href="ResampleSpectrum.html">ResampleSpectrum</a>, <a href="ScaleSpectrum.html">ScaleSpectrum</a></p><h2 id="6">Usage Example</h2><pre class="language-matlab">
<span class="keyword">function</span> ExampleMultiplySpectra()
    s1 = GaussSpectrum(400:500, 450,10);
    s2 = MakeSpectrum([430 470],[0 2]);
    prodspec = MultiplySpectra(s1, s2);
    figure();
    clf;
    hold <span class="string">on</span>;
    plot(s1.lam, s1.val);
    plot(s2.lam, s2.val);
    plot(prodspec.lam, prodspec.val);
    legend({<span class="string">'s1'</span>,<span class="string">'s2'</span>,<span class="string">'prodspec = s1*s2'</span>},<span class="string">'Location'</span>,<span class="string">'northwest'</span>);
    
<span class="keyword">end</span>

</pre><img vspace="5" hspace="5" src="MultiplySpectra_01.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% MultiplySpectra
% 
% <html>
%  <p style="font-size:75%;">Navigate to: &nbsp; 
% <a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
% <a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp; 
% <a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp; 
% Source code: <a href = "file:../MultiplySpectra.m"> MultiplySpectra.m</a>
% </p>
% </html>
%
% Multiply two spectra
%% Syntax
% rv = |MultiplySpectra(lhs, rhs)|
%% Input Arguments
% * |lhs|: A valid spectrum, i.e. a struct with two array fields, |lam| and |val| (see <SpectrumSanityCheck.html SpectrumSanityCheck> for detailed requirements)
% * |rhs|: Likewise
%% Output Arguments
% * |rv|: A spectrum modeling the product.
%% Algorithm
% A spectrum in this library models a continuous, piecewise linear function of wavelength. For a given array of
% wavelenghts, the modeled spectrum is linear between wavelength points, and zero outside the wavelength domain. At the
% ends of the wavelength domain the modeled spectrum may drop discontinously to zero. (If you don't like these discontinuities at the domain boundary, add end
% points with zero values.). The product spectrum's wavelength points consist of the "interweaved" wavelength arrays of
% |lhs| and|rhs|, where they overlap. If they don't overlap at all, a spectrum is returned with two wavelength points
% and both values zero.
%
% At each wavelength point, one value is taken from the corresponding point of one spectrum and the
% linearly interpolated point of the other spectrum, then these two are multiplied. Strictly speaking, the product spectrum would not be piecewise
% linear, it would be piecewise quadratic. However, this is neglected here. If a better approximation to the quadratic
% product spectrum is desired, you may resample |lhs| and/or |rhs| on a finer wavelength array using
% <ResampleSpectrum.html ResampleSpectrum>.
%% See also
% <AddSpectra.html AddSpectra>, <AddWeightedSpectra.html AddWeightedSpectra>, <IntegrateSpectrum.html
% IntegrateSpectrum>, <ResampleSpectrum.html ResampleSpectrum>, <ScaleSpectrum.html ScaleSpectrum>
%% Usage Example
% <include>Examples/ExampleMultiplySpectra.m</include>

% publish with publishWithStandardExample('filename.m') in PublishDocumentation.m

% JMO Spectrum Library, 2021. See https://github.com/JuliusMuschaweck/JMO_Spectrum
% I dedicate the JMO_Spectrum library to the public domain under Creative Commons Zero 
% (https://creativecommons.org/publicdomain/zero/1.0/legalcode)
%

function rv = MultiplySpectra(lhs, rhs)
    % multiply spectra lhs and rhs, checking for overlap
    %
    % Parameters:
    %   lhs: A valid spectrum
    %   rhs: A valid spectrum
    % Results: 
    %   rv: The multiplied spectrum, with the wavelengths interweaved where they overlap
    %
    % Spectra in this library are always continuous, and assumed to be linear between the data points.
    % Now, when multiplying such piecewise linear functions, viewed as functions defined over
    % all reals (zero outside the wavelength range), the product would NOT be piecewise linear: It would be
    % piecewise quadratic. However, we assume piecewise linearity not only for simplicity, but also
    % because we just don't know what the spectrum does between support points. So we apply the same
    % logic to the product of two spectra: When a wavelength point occurs in both spectra, no problem.
    % When a wavelength point occurs only in one spectrum, we interpolate the other spectrum linearly to
    % obtain the data point of the product. Then, this sequence of points is again linearly interpolated,
    % and NOT assumed to be piecewise quadratic.
    [~,~,lhs] = SpectrumSanityCheck(lhs);
    [~,~,rhs] = SpectrumSanityCheck(rhs);
    % treat equal lambda arrays
    if isequal(lhs.lam, rhs.lam)
        rv.lam = lhs.lam;
        rv.val = lhs.val .* rhs.val;
        return;
    end
    % treat no overlap case
    % use <= to avoid single line spectra
    if (lhs.lam(end) <= rhs.lam(1))
        rv.lam = [lhs.lam(1),rhs.lam(end)];
        rv.val = [0,0];
        return;
    end
    if (rhs.lam(end) <= lhs.lam(1))
        rv.lam = [rhs.lam(1),lhs.lam(end)];
        rv.val = [0,0];
        return;
    end
    % treat overlapping, unequal lambdas
    % result nonzero only in [lam0;lam1] interval
    lam0 = max(lhs.lam(1), rhs.lam(1));
    lam1 = min(lhs.lam(end), rhs.lam(end));
    % compute interveawed lam, removing duplicates
    tmplam = unique(sort(cat(1,lhs.lam,rhs.lam)));
    tmpIdx = (tmplam >= lam0) & (tmplam <= lam1);
    rv.lam = tmplam(tmpIdx);
    if isempty(rv.lam)
        error('MultiplySpectra: This cannot happen');
    end
    % Interpolate both lhs and rhs, multiply elementwise
    vl = LinInterpol(lhs.lam,lhs.val,rv.lam);
    vr = LinInterpol(rhs.lam,rhs.val,rv.lam);
    rv.val = vl .* vr;
end
##### SOURCE END #####
--></body></html>