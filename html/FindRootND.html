
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>FindRootND</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-02-12"><meta name="DC.source" content="FindRootND.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>FindRootND</h1><!--introduction--><p>
 <p style="font-size:75%;">Navigate to: &nbsp;
<a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
<a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp;
<a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp;
Source code: <a href = "file:../FindRootND.m"> FindRootND.m</a>
</p>
</p><p>Finds multidimensional root of function in N dimensions, without derivatives</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Input Arguments</a></li><li><a href="#3">Output Arguments</a></li><li><a href="#4">Algorithm</a></li><li><a href="#5">See also</a></li><li><a href="#6">Usage Example</a></li></ul></div><h2 id="1">Syntax</h2><p><tt>[rv, ok, info] = FindRootND(func, x0, opts)</tt></p><h2 id="2">Input Arguments</h2><div><ul><li><tt>func</tt>: handle to function with signature <tt>rv = func(x)</tt>, where both <tt>rv</tt> and <tt>x</tt> are vectors of same length <tt>n</tt></li><li><tt>x0</tt>: double vector, with length <tt>n</tt>. The starting point for the search</li><li><tt>opts</tt>: Name-Value pairs</li></ul></div><p>
<p style="margin-left: 25px">
<table border=1>
<tr><td> <b>Name</b>      </td> <td>  <b>Type</b>     </td> <td><b>Value</b>      </td> <td><b>Meaning</b>                              </td></tr>
<tr><td> 'maxIterations'  </td> <td> positive integer </td> <td> 100 (default)    </td> <td> max. number of line search iterations      </td></tr>
<tr><td> 'tolF'           </td> <td> positive double  </td> <td> 1e-8 (default)   </td> <td> max. abs. function value for termination   </td></tr>
<tr><td> 'tolX'           </td> <td> positive double  </td> <td> 1e-12 (default)  </td> <td> max. abs. or rel. change in any x component for termination   </td></tr>
<tr><td> 'maxStepX'       </td> <td> positive double  </td> <td> 100 (default)    </td> <td> max. abs. or rel. step in x for line search </td></tr>
<tr><td> 'tolMin'         </td> <td> positive double  </td> <td> 1e-12 (default)  </td> <td> tolerance for local minimum detection </td></tr>
</table>
</p>
</p><h2 id="3">Output Arguments</h2><div><ul><li><tt>rv</tt>: double vector of length <tt>n</tt>. The <tt>x</tt> value at the root.</li><li><tt>ok</tt>: scalar logical. <tt>true</tt> for success, <tt>false</tt> for failure</li><li><tt>info</tt>: <tt>struct</tt> with fields <tt>fvec</tt> (the last function value), <tt>msg</tt> (a diagnostic string), <tt>iter</tt> (the number of line search iterations), and <tt>history</tt>. <tt>history</tt> is a struct with fields <tt>x</tt>, <tt>fvec</tt>, and <tt>xRestart</tt>. They all are matrices with size <tt>(2, iter)</tt>: the history of x and function values, and the x values where the Jacobian estimate was reset.</li></ul></div><h2 id="4">Algorithm</h2><p>Implements Broyden's method (see <a href="https://en.wikipedia.org/wiki/Broyden%27s_method">https://en.wikipedia.org/wiki/Broyden%27s_method</a>, closely following the implementation in Press et al., Numerical Recipes, chapter 9.7.3. This is a quasi-Newton method, where the Jacobian is estimated by simple forward differencing and approximately updated using the function value history. In other words, it is a multidimensional generalization of the secant method.</p><h2 id="5">See also</h2><p><a href="FindRoot1D.html">FindRoot1D</a>, Matlab's <tt>fsolve</tt> in the Optimization toolbox.</p><h2 id="6">Usage Example</h2><pre class="language-matlab">
<span class="keyword">function</span> ExampleFindRootND()
    figure();
    clf;
    [xx,yy] = meshgrid((-2):0.05:3, (-4):0.05:1);
    zz1 = arrayfun(@(x,y) ff(x,y,1), xx, yy);
    zz2 = arrayfun(@(x,y) ff(x,y,2), xx, yy);
    hold <span class="string">on</span>;
    contour(xx,yy,zz1,[-2, 0, 2],<span class="string">'r'</span>,<span class="string">'ShowText'</span>,<span class="string">'on'</span>);
    contour(xx,yy,zz2,[-2, 0, 2],<span class="string">'b'</span>,<span class="string">'ShowText'</span>,<span class="string">'on'</span>);
    
    x0 = [2;-3];
    scatter(x0(1), x0(2),<span class="string">'x'</span>);
   
    [rv, ok, info] = FindRootND(@f, x0);
    plot(info.history.x(1,:), info.history.x(2,:), <span class="string">'-x'</span>,<span class="string">'LineWidth'</span>,2)
    plot(info.history.xRestart(1,:), info.history.xRestart(2,:), <span class="string">'o'</span>)

    x0 = [0;0];
    scatter(x0(1), x0(2),<span class="string">'x'</span>);
   
    [rv, ok, info] = FindRootND(@f, x0);
    plot(info.history.x(1,:), info.history.x(2,:), <span class="string">'-x'</span>,<span class="string">'LineWidth'</span>,2)
    plot(info.history.xRestart(1,:), info.history.xRestart(2,:), <span class="string">'o'</span>)

    x0 = [-1;0.5];
    scatter(x0(1), x0(2),<span class="string">'x'</span>);
   
    [rv, ok, info] = FindRootND(@f, x0);
    plot(info.history.x(1,:), info.history.x(2,:), <span class="string">'-x'</span>,<span class="string">'LineWidth'</span>,2)
    plot(info.history.xRestart(1,:), info.history.xRestart(2,:), <span class="string">'o'</span>)
<span class="keyword">end</span>

<span class="keyword">function</span> rv = ff(x, y, i)
    tmp = f([x;y]);
    rv = tmp(i);
<span class="keyword">end</span>

<span class="keyword">function</span> rv = f(x)
    xx = x(1);
    yy = x(2);
    rv = [exp(xx) + yy; 2 + yy - xx^2];
<span class="keyword">end</span>

</pre><img vspace="5" hspace="5" src="FindRootND_01.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% FindRootND
% 
% <html>
%  <p style="font-size:75%;">Navigate to: &nbsp; 
% <a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
% <a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp; 
% <a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp; 
% Source code: <a href = "file:../FindRootND.m"> FindRootND.m</a>
% </p>
% </html>
%
% Finds multidimensional root of function in N dimensions, without derivatives
%% Syntax
% |[rv, ok, info] = FindRootND(func, x0, opts)|
%% Input Arguments
% * |func|: handle to function with signature |rv = func(x)|, where both |rv| and |x| are vectors of same length |n|
% * |x0|: double vector, with length |n|. The starting point for the search
% * |opts|: Name-Value pairs
%
% <html>
% <p style="margin-left: 25px">
% <table border=1>
% <tr><td> <b>Name</b>      </td> <td>  <b>Type</b>     </td> <td><b>Value</b>      </td> <td><b>Meaning</b>                              </td></tr>
% <tr><td> 'maxIterations'  </td> <td> positive integer </td> <td> 100 (default)    </td> <td> max. number of line search iterations      </td></tr>
% <tr><td> 'tolF'           </td> <td> positive double  </td> <td> 1e-8 (default)   </td> <td> max. abs. function value for termination   </td></tr>
% <tr><td> 'tolX'           </td> <td> positive double  </td> <td> 1e-12 (default)  </td> <td> max. abs. or rel. change in any x component for termination   </td></tr>
% <tr><td> 'maxStepX'       </td> <td> positive double  </td> <td> 100 (default)    </td> <td> max. abs. or rel. step in x for line search </td></tr>
% <tr><td> 'tolMin'         </td> <td> positive double  </td> <td> 1e-12 (default)  </td> <td> tolerance for local minimum detection </td></tr>
% </table>
% </p>
% </html>
%

%% Output Arguments
% * |rv|: double vector of length |n|. The |x| value at the root.
% * |ok|: scalar logical. |true| for success, |false| for failure
% * |info|: |struct| with fields |fvec| (the last function value), |msg| (a diagnostic string), |iter| (the number of
% line search iterations), and |history|. |history| is a struct with fields |x|, |fvec|, and |xRestart|. They all are
% matrices with size |(2, iter)|: the history of x and function values, and the x values where the Jacobian estimate was
% reset.

%% Algorithm
% Implements Broyden's method (see <https://en.wikipedia.org/wiki/Broyden%27s_method>, closely following the
% implementation in Press et al., Numerical Recipes, chapter 9.7.3. This is a quasi-Newton method, where the Jacobian is
% estimated by simple forward differencing and approximately updated using the function value history. In other words,
% it is a multidimensional generalization of the secant method.
%% See also
% <FindRoot1D.html FindRoot1D>, Matlab's |fsolve| in the Optimization toolbox.
%% Usage Example
% <include>Examples/ExampleFindRootND.m</include>

% publish with publishWithStandardExample('filename.m') in PublishDocumentation.m

% JMO Spectrum Library, 2021. See https://github.com/JuliusMuschaweck/JMO_Spectrum
% I dedicate the JMO_Spectrum library to the public domain under Creative Commons Zero 
% (https://creativecommons.org/publicdomain/zero/1.0/legalcode)
%

function [rv, ok, info] = FindRootND(func, x0, opts)
    arguments
        func
        x0 (:,1) double
        opts.maxIterations (1,1) double {mustBePositive, mustBeInteger} = 200
        opts.tolF (1,1) double {mustBePositive} = 1e-8
        opts.tolX (1,1) double {mustBePositive} = 1e-12
        opts.maxStepX (1,1) double {mustBePositive} = 100
        opts.tolMin (1,1) double {mustBePositive} = 1e-12
    end
    x0 = x0(:);
    n = length(x0);
    x = x0;
    xold = NaN(n,1);
    ff = @(xx) reshape(func(xx), n, 1);
    [f, fvec] = Fmin(ff, x);
    info = struct();
    info.history.x = x;
    info.history.fvec = fvec;
    info.history.xRestart = x;
    restart = true; % trigger new Jacobi matrix calculation
    % test for initial guess being a root
    if all(abs(fvec) < opts.tolF)
        rv = x;
        ok = true;
        info.fvec = fvec;
        info.msg = 'Initial guess was root';
        info.iter = 0;
        return;
    end
    % calc stepmax for line search
    stepmax = opts.maxStepX * max(norm(x), n);
    % iteration loop
    for iter = 1:opts.maxIterations
        if restart % new jacobi and QR
            [jac, fvec] = Jacobi(ff, x);
            if iter > 2
                info.history.xRestart(:,end+1) = x;
            end
            [Q,R] = qr(jac);
            if IsSingularR(R)
                [Q,R] = qr(eye(n));
            end
        else % Broyden update
            s = x - xold;
            t = R * s;
            w = fvec - fvec_old - Q' * t;
            w_lim = eps * (abs(fvec) + abs(fvec_old));
            w_noisy = abs(w) < w_lim;
            w(w_noisy) = 0;
            if ~all(w_noisy) % don't update with noisy w
                t = Q' * w;
                s = s / (s' * s);
                % [Q, R] = qrupdate(Q, R, t, s); % different meaning between Matlab and Press
                [Q, R] = qrupdate(Q, R, w, s); % different meaning between Matlab and Press
                if IsSingularR(R)
                    error('FindRootND: Singular Broyden update');
                end
            end
        end
        % rhs  -Q' * f
        p = - Q' * fvec;
        % estimate gradient F
        g = - R' * p;
        xold = x;
        fvec_old = fvec;
        fold = f;
        % solve linear equations
        p = R \ p;
        slope = g' * p;
        if slope >= 0
            restart = true;
            continue;
        end
        % line search
        fmin = @(xx) Fmin(ff, xx);
        [x, f, fvec, tooClose] = LineSearch(fmin, xold, fold, g, p, stepmax);
        info.history.x(:,end+1) = x;
        info.history.fvec(:,end+1) = fvec;
        % test for convergence
        if max(abs(fvec)) < opts.tolF
            rv = x;
            ok = true;
            info.fvec = fvec;
            info.msg = 'Root found';
            info.iter = iter;
            return;
        end
        % if failed to find new x
        if tooClose
        %   if just reinitalized Jacobi -> error
            if restart
                rv = NaN(n,1);
                ok = false;
                info.fvec = fvec;
                info.last_x = x;
                info.msg = 'no root found';
                info.iter = iter;
                return;
            end
            %   check for spurious convergence
            xTest = MaxAbsOrOne(x);
            test = max(abs(g) .* xTest / max(f, 0.5*n));
            if test < opts.tolMin
                rv = NaN(n,1);
                ok = false;
                info.fvec = fvec;
                info.last_x = x;
                info.msg = 'no root found: converged on minimum of f*f';
                info.iter = iter;
                return;
            end
            %   trigger restart jacobi
            restart = true;
        else % (successful step)
            %   untrigger restart jacobi
            restart = false;
            %   check for convergence
            test = max( abs(x - xold) ./ MaxAbsOrOne(x));
            if test < opts.tolX
                rv = x;
                ok = true;
                info.fvec = fvec;
                info.msg = 'Initial guess was root';
                info.iter = 0;
                return;
            end
            %   use update for next iteration
        end
    end % end iteration loop
    error('FindRootND: max. iterations == %g exceeded', opts.maxIterations);
end

function [rv, fvec] = Fmin( ff, x )
    fvec = ff(x);
    rv = 0.5 * (fvec' * fvec);
end

function rv = MaxAbsOrOne(xx)
    rv = abs(xx);
    rv( rv < 1 ) = 1;
end

function [rv, fvec] = Jacobi(func, x) % forward difference jacobi matrix
    EPS = 1e-8;
    n = length(x);
    rv = NaN(n,n);
    xh = x;
    fvec = func(x);
    for j = 1:n
        temp = xh(j);
        h = EPS * abs(temp);
        if h == 0
            h = EPS;
        end
        xh(j) = temp + h; % reduce finite precision error
        h = xh(j) - temp;
        f = func(xh); 
        xh(j) = temp;
        df = (f - fvec) / h;
        rv(j,:) = (df(:))';
    end
    rv = rv';
end

function rv = IsSingularR( R )
    dd = abs(diag(R));
    sumdd = sum(dd);
    rv = (sumdd == 0 || min(dd) / sumdd < 10 * eps);
end

function [x, f, fvec, tooClose] = LineSearch(func, xold, fold, g, p, stepmax)
    ALF = 1e-4;
    TOLX = eps;
    alam2 = 0;
    f2 = 0;
    % n = length(xold);
    tooClose = false;
    sum = sqrt(p' * p);
    if sum > stepmax
        p = p * (stepmax / sum);
    end
    slope = g' * p;
    if slope >= 0
        error('FindRootND: positive slope in LineSearch');
    end
    test = max(abs(p) ./ MaxAbsOrOne(xold));
    alamin = TOLX / test;
    alam = 1;
    while true
        x = xold + alam * p;
        [f, fvec] = func(x);
        if alam < alamin % too close to xold
            x = xold;
            tooClose = true;
            return;
        elseif f <= fold + ALF * alam * slope % all is well
            return;
        else % backtrack
            if alam == 1 % first backtrack
                tmplam = - slope / (2 * (f - fold - slope));
            else % next backtracks
                rhs1 = (f - fold - alam*slope) / alam^2;
                rhs2 = (f2 - fold  - alam2*slope) / alam2^2;
                d_alam = alam - alam2;
                a = (rhs1 - rhs2) / d_alam;
                b = (alam2 * rhs1 + alam * rhs2) / d_alam;
                if a == 0
                    tmplam = -slope / (2*b);
                else
                    disc = b^2 - 3 * a * slope;
                    if disc < 0
                        tmplam = 0.5 * alam;
                    elseif b <= 0
                        tmplam  = (-b + sqrt(disc)) / (3*a);
                    else
                        tmplam = -slope / (b + sqrt(disc));
                    end
                end
                tmplam = min(tmplam, 0.5*alam);
            end
        end
        alam2 = alam;
        f2 = f;
        alam = max(tmplam, 0.1 * alam);
    end
end



##### SOURCE END #####
--></body></html>