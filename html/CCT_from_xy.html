
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>CCT_from_xy</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-02-12"><meta name="DC.source" content="CCT_from_xy.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>CCT_from_xy</h1><!--introduction--><p>
 <p style="font-size:75%;">Navigate to: &nbsp;
<a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
<a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp;
<a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp;
Source code: <a href = "file:../CCT_from_xy.m"> CCT_from_xy.m</a>
</p>
</p><p>Computes the correlated color temperature (CCT) of a spectrum</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Input Arguments</a></li><li><a href="#3">Output Arguments</a></li><li><a href="#4">Algorithm</a></li><li><a href="#5">See also</a></li><li><a href="#6">Usage Example</a></li></ul></div><h2 id="1">Syntax</h2><p><tt>[CCT, dist_uv, ok, errmsg] = CCT_from_xy(x,y)</tt></p><h2 id="2">Input Arguments</h2><div><ul><li><tt>x</tt>: Scalar double, CIE 1931 x coordinate</li><li><tt>y</tt>: Scalar double, CIE 1931 y coordinate</li></ul></div><h2 id="3">Output Arguments</h2><div><ul><li><tt>iCCT</tt>: scalar double. The correlated color temperature in Kelvin</li><li><tt>dist_uv</tt>: scalar double. The distance to the Planck locus in uv coordinates. Negative when below Planck locus (towards magenta).</li><li><tt>ok</tt>: When requested, function sets ok to false, sets iCCT and dist_uv to NaN in case of error instead of throwing error.</li><li><tt>errmsg</tt>: Contains error and warning message(s)</li></ul></div><h2 id="4">Algorithm</h2><p>For a CIE 1931 xy color point, transform it to CIE 1960 uv coordinates, and then find the closest point on the Planck locus in CIE 1960 uv coordinates. The absolute temperature corresponding to the blackbody radiation that yields this point on the Planck locus is the CCT. See also the official CIE definition <a href="https://cie.co.at/eilvterm/17-23-068">https://cie.co.at/eilvterm/17-23-068</a>.</p><div><ol><li>Data for the Planck locus is obtained by calling <a href="PlanckLocus.html">PlanckLocus</a>, giving 1001 uv points along the Planck locus from 500 K to 1e+11K, equidistant in 1/T, and thus not too non-equidistant in uv.</li><li>The closest of these 1001 uv points is determined by computing all 1001 distances and then looking for the minimum.</li><li>If that minimum is &gt; 0.09, there is an error, <tt>CCT = NaN; dist_uv = NaN;</tt>, and the function returns</li><li>If that minimum is &gt; 0.05, there is a warning (see <a href="https://cie.co.at/eilvterm/17-23-068">https://cie.co.at/eilvterm/17-23-068</a>), because the color is so far away from the Planck locus that it is too green or magenta for a self respecting CCT.</li><li>If the temperature corresponding to that minimum is &lt; 500.5 or &gt; 500,000, there is an error.</li><li>At correct CCT, the vector connecting uv and the CCT point on the Planck locus is perpendicular to the Planck locus tangent unit vector, i.e. their cross product must be zero. This zero point is determined by treating this cross product as a quadratic function of inverse temperature, and computing the root of this quadratic function.</li><li>The CCT is then the inverse of this root. The uv distance is computed by evaluating a spline interpolation function of u and v.</li></ol></div><h2 id="5">See also</h2><p><a href="CCT.html">CCT</a></p><h2 id="6">Usage Example</h2><pre class="language-matlab">
<span class="keyword">function</span> ExampleCCT_from_xy()
    T = 5704;
    s = CIE_Illuminant_D(T);
    XYZ = CIE1931_XYZ(s);
    testT = CCT_from_xy(XYZ.x, XYZ.y);
    fprintf(<span class="string">'Testing CCT_from_xy for CIE Illuminant D for %g K.\n'</span>,T);
    fprintf(<span class="string">'CCT = %g K, difference is %g K\n'</span>,testT, testT-T);

    ps = PlanckSpectrum(360:830,T);
    XYZp = CIE1931_XYZ(ps);
    testTp = CCT_from_xy(XYZp.x, XYZp.y);
   
    fprintf(<span class="string">'Testing CCT_from_xy for Planck spectrum at %g K.\n'</span>,T);
    fprintf(<span class="string">'CCT = %g K, difference is %g K\n'</span>,testTp, testTp-T);
    
<span class="keyword">end</span>

</pre><pre class="codeoutput">Testing CCT_from_xy for CIE Illuminant D for 5704 K.
CCT = 5701.65 K, difference is -2.35443 K
Testing CCT_from_xy for Planck spectrum at 5704 K.
CCT = 5704 K, difference is 0.000232545 K
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% CCT_from_xy
% 
% <html>
%  <p style="font-size:75%;">Navigate to: &nbsp; 
% <a href="JMOSpectrumLibrary.html"> Home</a> &nbsp; | &nbsp;
% <a href="AlphabeticList.html"> Alphabetic list</a> &nbsp; | &nbsp; 
% <a href="GroupedList.html"> Grouped list</a> &nbsp; | &nbsp; 
% Source code: <a href = "file:../CCT_from_xy.m"> CCT_from_xy.m</a>
% </p>
% </html>
%
% Computes the correlated color temperature (CCT) of a spectrum
%% Syntax
% |[CCT, dist_uv, ok, errmsg] = CCT_from_xy(x,y)|
%% Input Arguments
% * |x|: Scalar double, CIE 1931 x coordinate
% * |y|: Scalar double, CIE 1931 y coordinate
%% Output Arguments
% * |iCCT|: scalar double. The correlated color temperature in Kelvin
% * |dist_uv|: scalar double. The distance to the Planck locus in uv coordinates. Negative when below Planck locus
% (towards magenta).
% * |ok|: When requested, function sets ok to false, sets iCCT and dist_uv to NaN in case of error instead of throwing
% error.
% * |errmsg|: Contains error and warning message(s)
%% Algorithm
% For a CIE 1931 xy color point, transform it to CIE 1960 uv coordinates, and then find the
% closest point on the Planck locus in CIE 1960 uv coordinates. The absolute temperature corresponding to the blackbody
% radiation that yields this point on the Planck locus is the CCT. See also the official CIE definition
% <https://cie.co.at/eilvterm/17-23-068>. 
%
% # Data for the Planck locus is obtained by calling <PlanckLocus.html PlanckLocus>, giving 1001 uv points
% along the Planck locus from 500 K to 1e+11K, equidistant in 1/T, and thus not too non-equidistant in uv.
% # The closest of these 1001 uv points is determined by computing all 1001 distances and then looking for the minimum.
% # If that minimum is > 0.09, there is an error, |CCT = NaN; dist_uv = NaN;|, and the function returns
% # If that minimum is > 0.05, there is a warning (see <https://cie.co.at/eilvterm/17-23-068>), because the color is so
% far away from the Planck locus that it is too green or magenta for a self respecting CCT.
% # If the temperature corresponding to that minimum is < 500.5 or > 500,000, there is an error.
% # At correct CCT, the vector connecting uv and the CCT point on the Planck locus is perpendicular to the Planck locus
% tangent unit vector, i.e. their cross product must be zero. This zero point is determined by treating this cross
% product as a quadratic function of inverse temperature, and computing the root of this quadratic function.
% # The CCT is then the inverse of this root. The uv distance is computed by evaluating a spline interpolation function
% of u and v. 
%% See also
% <CCT.html CCT>
%% Usage Example
% <include>Examples/ExampleCCT_from_xy.m</include>

% publish with publishWithStandardExample('filename.m') in PublishDocumentation.m

% JMO Spectrum Library, 2021. See https://github.com/JuliusMuschaweck/JMO_Spectrum
% I dedicate the JMO_Spectrum library to the public domain under Creative Commons Zero 
% (https://creativecommons.org/publicdomain/zero/1.0/legalcode)
%

function [CCT, dist_uv, ok, errmsg] = CCT_from_xy(x,y)
% function [CCT, dist_uv] = CCT_from_xy(x,y)
% computes CCT in the range of 1000K to 1000.000K with extreme precision
% dist_uv is the distance to the Planck locus in uv coordinates, should be
% less than 0.05 for valid CCT
% There is a warning for duv > 0.05, and an error for duv > 0.09, or CCT out of 1000K..10^6K range.
% However, if nargout >= 3, i.e. the 'ok' return value is queried, no warnings or errors are raised.
% Instead, ok == true (if no error) || false , and errmsg == '' || 'warning: ...' || 'error: ...', and if there is an
% error, then CCT = NaN and dist_uv = NaN
    pl = PlanckLocus();
    den = -2*x + 12*y + 3;
    u = 4 * x / den;
    v = 6 * y / den;
    du = u - pl.u;
    dv = v - pl.v;
    duv = sqrt(du.^2 + dv.^2);
    [minduv, iminduv] = min(duv);
    okcheck = nargout >= 3;
    ok = false; CCT = NaN; dist_uv = NaN; errmsg = '';
    if minduv > 0.09
        if okcheck
            errmsg = 'CCT error: duv > 0.09'; 
            return;
        else
            error('CCT: duv > 0.09');
        end
    end
    if iminduv < 2 || iminduv >= pl.nT
        if okcheck
            errmsg = 'CCT error: out of 500K ... 500,000K range'; 
            return;
        else
            error('CCT: out of 500K ... 500,000K range');
        end
    end
    ok = true;
    if minduv > 0.05
        if okcheck
            errmsg = 'CCT warning: duv > 0.05'; 
        else
            warning('CCT: duv > 0.05');
        end
    end
%     test0 = JuddDistance(invT);
%     testp = JuddDistance(pl.invT(iminduv+1));
%     testm = JuddDistance(pl.invT(iminduv-1));    

    dtest0 = DirectJuddDistance(iminduv);
    dtestp = DirectJuddDistance(iminduv+1);
    dtestm = DirectJuddDistance(iminduv-1);    
    
    y1 = dtestm;
    y2 = dtest0;
    y3 = dtestp;
    
    aa = y3/2 - y2 + y1/2;
    bb = -y3/2 + 2*y2 - 3/2 * y1;
    cc = y1;    
    
    mydet = bb^2 - 4 * aa * cc;
    if mydet < 0
        error('CCT: no parabolic solution');
    end
    x1 = (-bb + sqrt(mydet)) / (2*aa);
    x2 = (-bb - sqrt(mydet)) / (2*aa);
    if (abs(x1) < abs(x2))
        xx = x1;
    else
        xx = x2;
    end
    dinvT = pl.invT(2) - pl.invT(1);
    invrv = pl.invT(iminduv-1) + xx * dinvT;
    CCT = 1/invrv;
    if nargout > 1
        duu = u - ppval(pl.spline_u, invrv);
        dvv = v - ppval(pl.spline_v, invrv);
        dist_uv = norm([duu,dvv]);
        duc = u - 0.35; % uv "center" of planck locus
        dvc = v - 0.25;
        if (duu * duc + dvv * dvc) < 0 % below planck
            dist_uv = dist_uv * (-1);
        end
    end
    
%     function rv2 = JuddDistance(invT)
%         uu = ppval(pl.spline_u, invT);
%         vv = ppval(pl.spline_v, invT);
%         Ju = - ppval(pl.spline_dv_dinvT, invT);
%         Jv = ppval(pl.spline_du_dinvT, invT);
%         J = [Ju, Jv] / sqrt(Ju^2+Jv^2);
%         duuvv = [u-uu,v-vv];
%         rv2 = duuvv(1) * J(2) - duuvv(2) * J(1);
%     end
    
    function rv3 = DirectJuddDistance( idx )
        uu = pl.spline_u.coefs(idx,4);
        vv = pl.spline_v.coefs(idx,4);
        Ju = - pl.spline_dv_dinvT.coefs(idx,3);
        Jv = pl.spline_du_dinvT.coefs(idx,3);
        J = [Ju, Jv] / sqrt(Ju^2+Jv^2);
        duuvv = [u-uu,v-vv];
        rv3 = duuvv(1) * J(2) - duuvv(2) * J(1);
    end
end


##### SOURCE END #####
--></body></html>